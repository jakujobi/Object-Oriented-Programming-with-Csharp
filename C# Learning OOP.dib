#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"}]}}

#!markdown

---
# **Basics of C#** - Printing, variables, operators, data types, strings, comments

#!markdown

## Input and Output
- Input: 
- `Console.ReadLine()` reads from the console and returns a string
  - It stops when enter key is pressed
- `Console.Read()` returnes the ASCII value of the key pressed
  - It returns it as a string
  - If there are no more characters to be read, it returns -1
- `Console.ReadKey()` returns information about the key pressed

Output:
- `Console.Write()` writes to the console without a new line
- `Console.WriteLine()` writes to the console with a new line

#!csharp

Console.Write("Hello World");
Console.WriteLine("Hello World");
Console.Write("Hello World");
Console.WriteLine("Hello World");

#!csharp

Console.Write("Enter your name: ");
string greet = Console.ReadLine();
Console.WriteLine($"{greet}");

int character = Console.Read();

#!markdown

## Basics

#!markdown

`variable.GetType()` is used to check the type of the variable

Types:
- `var` : automatically assigns the type of variable
- `dynamic` : the type isn't checked until runtime

- `int` : integer
- `float` : floating point number
    - floats have to end in `f` or else they will be a double
- `double`: double precision floating point number
- `short` : short integers between -32768 and 32767
- `long` : long integers between -9223372036854775808 and 9223372036854775807

Literals:
- `char` : character
    - char x = 'a';
- `string` : text
    string x = "hello";
- `bool` : boolean (true or false)
    - bool x = true;
    - bool y = false;

#!csharp

int x = 10;
float y = 5.4f;
var z = x + y;
Console.WriteLine(y.GetType()); // System.Single

#!csharp

string aFriend = "Bill";
Console.WriteLine(aFriend);

//

string aFriend = "Maira";
Console.WriteLine(aFriend);

#!markdown

#### Assigning of same type
you can use commas to assign multiple variables at once.

#!csharp

int x = 10, y = 5, z = 20;
Console.WriteLine(x + y + z);

#!markdown

---
# **Strings**

#!markdown

### [String Interpolation](https://docs.microsoft.com/dotnet/csharp/language-reference/tokens/interpolated)

Use `$` to use multiple variables and expressions in strings.
    - `Console.WriteLine($"Hello, {fname}! {10 + 5}");`
- **Concatenation:** `+` is used to concatenate strings
- **Length of string:** Use the `Length` property
    - `variable.Length` will return length

#!csharp

string aFriend = "Stormy";
Console.WriteLine("Hello " + aFriend);

string firstFriend = "Maria";
string secondFriend = "Sage";
Console.WriteLine($"My friends are {firstFriend} and {secondFriend}");

Console.WriteLine($"The name {firstFriend} has {firstFriend.Length} letters.");
Console.WriteLine($"The name {secondFriend} has {secondFriend.Length} letters. {10 + 5}");

#!markdown

### Splitting strings
- `.Split()`
  - Splits a string into an array of substrings based on the spaces in the string.
- `Split(string)`:
  - splits based on the inputed string
- `Split(char)`
  - based on the char character
- `Split(string, int)`
  - splits into maximum number of substrings based on the inputed string
- `Split(char, int)`
  - splits into maximum number of substrings based on the inputed char

#!csharp

string str = "Hello World";
string[] words = str.Split(); // ["Hello", "World"]

string str1 = "Hello,World";
string[] words = str.Split(','); // ["Hello", "World"]

string str2 = "Hello-World";
string[] words = str.Split("-"); // ["Hello", "World"]

string str4 = "Hello,World,How,Are,You";
string[] words = str.Split(',', 3); // ["Hello", "World", "How,Are,You"]

string str5 = "Hello-World-How-Are-You";
string[] words = str.Split("-", 3); // ["Hello", "World", "How-Are-You"]

#!markdown

### Changing case
- `.ToUpper()` : converts to uppercase
- `.ToLower()`  : converts to lowercase

#!markdown

### Trimming strings:
- `.Trim()` : removes whitespace in front and back
- `.TrimStart()` : removes leading whitespace
- `.TrimEnd()` : removes trailing whitespace

#!csharp

string greeting = "      Hello World!       ";
Console.WriteLine($"[{greeting}]");

string trimmedGreeting = greeting.TrimStart();
Console.WriteLine($"[{trimmedGreeting}]");

trimmedGreeting = greeting.TrimEnd();
Console.WriteLine($"[{trimmedGreeting}]");

trimmedGreeting = greeting.Trim();
Console.WriteLine($"[{trimmedGreeting}]");

#!markdown

### Replacing text in a string `.Replace("old", "new")`
This replaces the occurence of `iniWord` with `newWord`.     `variable.Replace("iniWord", "newWord")`

#!csharp

string sayHello = "Hello World!";
Console.WriteLine(sayHello);
sayHello = sayHello.Replace("Hello", "Greetings");
Console.WriteLine(sayHello);

#!csharp

string Hozier = "Take me to church,\nI'll worship like a dog at the shrine of your lies.\nI'll tell you my sins and you can sharpen your knife.\nOffer me that deathless death, good God, let me give you my life.\n";
Console.WriteLine($"Hey\n" + Hozier + $"\n");

Console.WriteLine(Hozier.ToUpper());    //converts to uppercase
Console.WriteLine(Hozier.ToLower());    //converts to lowercase

Console.WriteLine(Hozier.Contains("church"));    //checks if the string contains the word "church"
Console.WriteLine(Hozier.Contains("  "));    //checks if the string contains the word "  "

#!markdown

#### Searching strings `.Contains()`
We search strings using the `Contains` method. It returns a boolean value.
`variable.Contains("substring")`

#!csharp

string songLyrics = "You say goodbye, and I say hello";
Console.WriteLine(songLyrics.Contains("goodbye"));
Console.WriteLine(songLyrics.Contains("greetings"));

#!csharp

// We search strings using the `Contains` method. It returns a boolean value.
string myString = "Hello World";
Console.WriteLine(myString.Contains("World"));

#!markdown

### Comments

You can write comments by using the two forward-slash characters to indicate everything after them is a comment.

#!csharp

// This is a comment

#!markdown

The below script needs to be able to find the current output cell; this is an easy method to get it.

You can create comments that span multiple lines by using slash asterisk fencing like the following:

#!csharp

/*
This is a multi-line comment

and this is still commented out
*/

#!markdown

## Variables: They are like C++

#!markdown

#### Built-In Variable Types

Variables can be declared of various **types** and then interacted with. The simplest types in C# are called [Built-In Types](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/built-in-types)

We define variables using in-memory storage for a type by preceeding the name of the variable we would like to create with the type of the variable we are creating.

#!csharp

int i = 10;
double j = 5.5d;
char c = 'C';

c

#!markdown

#### The var keyword

Sometimes, its a little cumbersome to declare a variable, assign a value, and have to specify the type before it. C# has built-in type inference and you can use the var keyword to force the compiler to detect the actual type being created and set the variable to the type of the value being assigned.

#!csharp

var i                             = 10;
var someReallyLongVariableName    = 9;
var foo                           = "Something";
display(someReallyLongVariableName);

var c = 'C';
c

#!markdown

You can ONLY use the var keyword when creating and assigning the variable in one statement.

#### Real Literals

We can declare double, float, and decimal types with simple numeric notation, but we need to force the literal numbers we assign to be the correct type to match the variable type expected.

To do this, we add a d, f, or m suffix to a number being assigned.  Try changing the suffix on the number in the next block and see what types it assigns.

#!csharp

var myNumber = 4f;
myNumber.GetType()

#!markdown

### Type Casting

We can convert a variable between different types in several ways:

1. Assign to a variable of a different type
1. Convert between types by placing the destination type in parenthesis

#!csharp

int valueA = 10;
decimal valueB = valueA; // Implicit conversion

display(valueB);

decimal valueC = 10;
//int valueD = valueC;      // This errors out because int cannot be implicitly converted to by a decimal
int valueD = (int)valueC;   // Explicitly convert valueC to int with the (int) modifier

display(valueD);

#!markdown

### Operators: Same as C++

#!markdown

Now that we have some basic types and can create variables, it would sure be nice to have them interact with each other. [Operators](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/) can be used to interact with our variables.

Let's start by declaring two variables, apples and oranges and interact with them using different operators. Try changing some of the values and tinkering with the operators in the following code snippets.

#!csharp

var apples = 100m;   // Decimal value
var oranges = 30m;   // Decimal value

//display() is only available in Jupyter Notebook and Polyglot, not in C#

display(apples + oranges);

display("I have " + apples + " apples and " + oranges + " oranges.");

display(apples - oranges);

display(apples * oranges);

display(apples += 10);

display(apples -= 10);

display(apples *= 10);

display(apples /= 3m);

display(apples > oranges);

display(apples >= oranges);

display(apples < oranges);

display(apples <= oranges);

display(apples == oranges)

display(apples != oranges)

#!markdown

---
# **Loops and Conditionals**

#!markdown

#### Conditionals

There are two statement-level conditional interactions in C#: if and switch...case statements. If statements can be combined with any number of else if statements and a single else statement to route code flow and interactions across branches of code. [(Link to official docs)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/if-else)

Let's take a look at a simple if statement.

#!csharp

var seconds = DateTime.Now.Second;
display("Current seconds: " + seconds);

// A simple test, are the number of seconds a multiple of 2?
if (    seconds % 2 == 0     ) {
    // Do this thing when seconds are even
    display("seconds are even");
}

#!markdown

The if statement starts with the if keyword and continues with a test in parenthesis. Next, the code to be executed if the test evaluates to true is contained within curly braces { }. The use of braces is optional, as long as the code to be executed is a single line.

#!csharp

var seconds = DateTime.Now.Second;
display("Current seconds: " + seconds);

// One line if statement
if (seconds % 2 == 0) display("Seconds are even");

if (seconds % 2 == 1)
    display("Seconds are odd");


    display("This will always execute, even though it LOOKS LIKE its in the if statement");

#!markdown

Great, if the condition is met we can execute some code. What if we need some more complex branching and potentially apply secondary tests and code if those tests return false? We can start using the else and else if syntax to add these additional branches of code to be executed.

Let's look a more complex branching scenario:

#!csharp

var seconds = DateTime.Now.Second;
display("Current seconds: " + seconds);

if (seconds % 2 == 0) {
    display("Seconds are even");
} else if (seconds % 3 == 0) {
    display("Seconds are a multiple of 3");
} else if (seconds % 5 == 0) {
    display("Seconds are a multiple of 5");
} else {
    display("Seconds are neither even nor a multiple of 3");
}

if (seconds % 2 == 0)          display("Seconds are even");
else if (seconds % 3 == 0)     display("Seconds are a multiple of 3");
else if (seconds % 5 == 0)     display("Seconds are a multiple of 5");
else                           display("Seconds are neither even nor a multiple of 3");

#!markdown

Testing for one condition is fine... but what if we have a compound scenario where we need to test for multiple factors before we determine which branch to take?

You can chain together conditional tests using the logical OR | and the logical AND & operators.

#!csharp

var seconds = DateTime.Now.Second;
// seconds = 7;
display("Current seconds: " + seconds);

// Test for BOTH multiple of 2 AND a multiple of 3
if (seconds % 2 == 0 & seconds % 3 == 0) {
    display("Seconds are even AND a multiple of 3");
} else if (seconds % 2 == 0) {
    display("Seconds are even");
} else if (seconds % 3 == 0) {
    display("Seconds are a multiple of 3");

// Test for seconds to be a multiple of 5 OR a multiple of 7
} else if (seconds % 5 == 0 | seconds % 7 == 0) {
    display("Seconds are a multiple of 5 OR 7");
} else {
    display("Seconds are neither even nor a multiple of 3");
}

#!markdown

There is another scenario that you will see many developers use to prioritize the compound boolean test inside an if statement, and that is using the 'short circuit' operators && and ||. They're referred to as a 'short circuit' operators because they evaluate the first condition on the left and if necessary evaluate the condition on the right side of the operator.

The && operator is called the **Conditional Logical AND** operator or referred to as **AndAlso** in Visual Basic. This operator behaves as follows:

1. Evaluate the left-side of the operator
1. IF the left-side evaluates to false, return false and stop processing
1. ELSE return the result of evaluating the right-side of the operator

Here's an example:

#!csharp

var seconds = DateTime.Now.Second;
display("Current seconds: " + seconds);

bool MultipleOfThree() {
    display("MultipleOfThree was called");
    return seconds % 3 == 0;
}

if (seconds % 2 == 0 && MultipleOfThree()) {
    display("Seconds are even and a multiple of three");
}

if (seconds != null && seconds % 2 == 1) {
    display("Seconds are odd");
}

#!markdown

In this scenario, if the number of seconds are even then the MultipleOfThree method is executed. If the number of seconds is even and a multiple of three, then it is reported as such. We can also observe that when the number of seconds is even, the MultipleOfThree method is executed because it is reported in the output.

The || operator is called the **Conditional Logical OR operator** or referred to as the **OrElse** operator by the Visual Basic language. This operator behaves like the following:

1. Evaluate the left-side of the operator
1. IF the left-side evaluates to true, return true and stop processing
1. ELSE return the result of evaluating the right-side of the operator

Here's an example:

#!csharp

var seconds = DateTime.Now.Second;
// seconds = 6;
display("Current seconds: " + seconds);

bool MultipleOfThree() {
    display("MultipleOfThree was called");
    return seconds % 3 == 0;
}

if (seconds % 2 == 0 || MultipleOfThree()) {
    display("Seconds are even or a multiple of three");
}

#!markdown

#### Switch Statements

Sometimes we have a LOT of conditions and branches that we want to evaluate and potentially traverse in our code. The [switch statement](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/switch) allows you to configure using the switch, case, break, and default statements the various branches you could potentially step down.

Use switch (test expression) to perform your test. Then use a series of case (result): statements to provide the various branching code paths to potentially execute. You can allow processing to 'fall out' of one statement into the next, and even provide a default branch at the end to ensure a branch is executed if none of the cases are matched.

Let's look at a real example:

#!csharp

var dayOfTheWeek = DateTime.Now.DayOfWeek;
// dayOfTheWeek = DayOfWeek.Friday;

switch (dayOfTheWeek) {
    case DayOfWeek.Monday:
        display("Does somebody have a case of the Mondays?");
        break;
    case DayOfWeek.Tuesday:
        display("It's TACO TUESDAY at the cafe!");
        break;
    case DayOfWeek.Wednesday:
        display("Middle of the work-week... almost done!");
        break;
    case DayOfWeek.Thursday:
        display("Friday is ALMOST HERE!!");
        break;
    case DayOfWeek.Friday:
        display("The weekend starts.... NOW!");
        break;
    case DayOfWeek.Saturday:
        display("Relaxing... no school, no work...");
        break;
    case DayOfWeek.Sunday:
        display("School and work tomorrow?  Better have some fun NOW!");
        break;
    default:
        display("I don't care what day of the week it is... we're on HOLIDAY!");
        break;
}

#!markdown

We can add additional tests for case statements using a when clause as well:

#!csharp

var dayOfTheWeek = DateTime.Now.DayOfWeek;
var hourOfDay = DateTime.Now.Hour;
    
/*  Extra conditions to test with */
dayOfTheWeek = DayOfWeek.Monday;
hourOfDay = 17;
/* */

switch (dayOfTheWeek) {
    case DayOfWeek.Monday:
    case DayOfWeek.Tuesday:
    case DayOfWeek.Wednesday:
    case DayOfWeek.Thursday:
    case DayOfWeek.Friday when hourOfDay < 16:
        display("Work work work...");
        break;
    case DayOfWeek.Friday when hourOfDay >= 16:
        display("The weekend starts.... NOW!");
        break;
    case DayOfWeek.Saturday:
    case DayOfWeek.Sunday:
        display("Relaxing... no school, no work...");
        break;
}

#!markdown

#### For Loops
Similar to C++
`for (Initializer; Condition; Iterator) { CODE TO EXECUTE }`

for (var i=0; i<5; i++) {
}

#!csharp

for (var counter=0; counter<5; counter++) {
  display("Counting " + counter);
}

#!markdown

Loops can even count backwards! This is because the iterator expression at the end of the for statement can execute any code. Let's try it with the -= operator:

#!csharp

for (var counter=5; counter>0; counter-= 3) {
  display("Counting " + counter);
}

#!markdown

#### Break Statement in For loops

If you need to exit a loop and continue processing, you can execute the break statement.

In the following loop, it is configured to run forever with the counter value starting at 1 and continuing as long as the counter > 0. The break statement will be triggered once the counter crosses 10.

#!csharp

for (var counter=1; counter>0; counter++) {
  display("Counting " + counter);
  
  if (counter > 10) break;
  
}

#!markdown

#### For-Each Loops

We haven't covered collections yet, but you can run a for loop across all of the items in the collection (like an array) and interact with each of those items directly. The [foreach statement](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/foreach-in) will run the contents of the loop and pass into your varaible each element in the collection, one at a time.

Let's look at an example:

#!csharp

var arrNames = new string[] { "Fritz", "Scott", "Maria", "Jayme", "Maira", "James"};

foreach (var name in arrNames) {4
    display(name);
}

#!markdown

The `foreach` statement is functionally the same as the following for loop with an iterator:

#!csharp

for (var nameCounter = 0; nameCounter < arrNames.Length; nameCounter++) {
  display(arrNames[nameCounter]);
}

#!markdown

#### While and Do Loops

`while` and `do` loops have almost identical structure and perform the same task. You provide a test condition over which the contents of the loop should continue to be executed. The [while loop](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/while) executes the test FIRST before the loop statements, and the [do loop](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/do) executes the test AFTER the statements.

Consider the examples of each statement below. The each start with a counter value of 6. Only the do loop executes and the while loop does not execute as the test fails immediately.

#!csharp

var counter = 6;

while (counter < 5) {
    counter++;
    display(counter);
}

#!csharp

var counter = 6;

do {
    counter++;
    display(counter);
} while (counter < 5);

#!markdown

### Summary

There is so much more to cover about C# and interacting with the .NET frameworks.  You can learn more through our [Get Started with .NET series](https://dotnet.microsoft.com/learn)

#!markdown

---
# **Custom code**

#!markdown

## Print function
This function displays a string on the screen

#!csharp

//This function displays a message on the screen.

void Print(string message) {
    Console.WriteLine(message);
}

Print("Hello, World!");  // Test with a simple string
Print("");  // Test with an empty string
Print(null);  // Test with null
Print("12345");  // Test with a numeric string
Print(new string('a', 1000));  // Test with a long string

#!markdown

## Boilerplate code
- using System; is a using directive that allows you to use types in the System namespace without having to specify the full namespace.
- namespace MyApplication defines a namespace for your application. This is a way to group your code and avoid name collisions with other code.
- class Program defines a class named Program. This is where your application's code will go.
- static void Main(string[] args) defines the Main method, which is the entry point for your application. When your application starts, this is the first method that gets called.
- Console.WriteLine("Hello, World!"); is a line of code that prints "Hello, World!" to the console. This is just a placeholder, and you can replace it with whatever code you want - your application to run.

#!csharp

using System;

namespace MyApplication {
    class Program{
        static void Main(string[] args){
            Console.WriteLine("Hello, World!");
        }
    }
}

#!csharp

using System;
using System.Linq;
using System.Collections.Generic;

Console.WriteLine("Hello World!");

#!markdown

---
# **OOP in C#**

#!markdown

---
# **Classes & Objects**

#!markdown

All apps process data
- We pick appropriate types to determine how much space variable takes in memory and how fast it can be processed

Naming things
- CamelCase
- PascalCase
- Snake_case

## Storing text
- Literal string
- Verbatim string
- Raw string
  - Characters are enclosed in three or more double-qute characters
- Interpolated string
  - Characters are enclosed in curly braces
  - Can include variable
  - Need to use $ sign in front

### Dynamic Type
- The type is determined at runtime
- Can be changed

#!markdown

---
# **Namespace**

#!markdown

1. Add a new class file named ClassName.cs
2. use static System.Console
3. namespace NameOfNameSpace

This is known as a file-scoped namespace per file
You ca only have one file-scoped namespace per file

#!csharp

//Old way

using System;
using static System.Console;

namespace NameOfNameSpace{
    public class NameOfClass{
        //code
    }
}

#!csharp

//new way

using System;
namespace NameOfNameSpace;

public class NameOfClass
{
    //code
}

#!markdown

### Namespaces
A namespace is a container that lets us bundle similar code under a specific name to avoid name clashes between different parts of a program

Thay are used to organize and separate codes.
They can contain classes, structs, interfacees, enums, and delegates

#!csharp

//Example of codespace

namespace ProjectName{
    class Class1{

    }
}

//You can access the Class1 using ProjectName.Class1

#!markdown

- variables in C#

#!markdown

---
# **Enumerators**
- Its a distinct type that consists of a set of named constants
- Used to specify a symbolic names to integral values

#!csharp

enum UserRole {
  Admin,
  User,
  Guest
}
//UserRole.Admin is 0
//UserRole.User is 1
//UserRole.Guest is 3

#!markdown

---
# **Types, Variables, Fields, Operators**

#!markdown

## Verbs = Methods

- They are action words
- such as jump, marry, fly

## Nouns = Types, Variables, Fields, Operators

- Types: Categories like Animal and Car
- Fields or Properties: Parts of the noun

#!markdown

## Types

These are categories like Animal, Car

- Every type can be a class, struct, enum, interface or delegate
- String is a class
- int is a struct

### Dynamic types

- Can store any type of data, even objects.
- Flexibility comes at cost of performance
- Can’t be checked during build time, only during runtime
- Useful when working alongside non-.NET systems.

```csharp
dynamic FullName = "Jackson Onyebuchi";
```

### Var

- declares local variables

#!markdown

## Members

#!markdown

## Fields
Variable that is directly declared in a class or struct and belong to it.

- Can be read or written to.
- An example is the age or height
- Usually private, avoid making it public
    - This is discouraged coz it violates encapsulation principle.
- Can be accessed through methods, properties, or constructors in the class

```csharp
private int age; //This is a field
```

#!markdown

## Properties

Member of a class or struct that allows us to read, write or compute the value of a private field

- Can be used as public data members
- Also called accessors
- Allows data to be accessed easily and safely
- Can’t have the same name as the field, but can use title-case version of the field name

```csharp
private int age; //The filed
public int Age{
    get{return age;}
    set{age = value;}
}
```

### Auto-implemented properties

You can have a property without a field

- These create a private anonymous backing field that can only be accessed by the property’s `get` and `set` accessors.

```csharp
public int age {get; set;}
```

#!markdown

## Variable

Storage location with a type and name.

- Can be of built-in or user-defined types
    - e.g int, float, bool, void
- Data is temporarily stored in variables which are store in memory
- Data in memory is lost when the program ends

```csharp
int number = 10;
string name = "Jack";
```

#!markdown

## Access Modifiers

#!markdown

### Public
They can be accessed from anywhere they are referenced
```csharp
public int age;
public class Person{}
```
### Private
- Can only be accessed within the class or struct in which they are declared
- They are the default access modifier
```csharp
private int age;
private void CalculateBirthDate(){}
```
### Protected
- Can only be accessed within the class or struct in which they are declared and in derived classes
```csharp
protected int age;
protected void CalculateBirthDate(){}
```
### Internal
- Can be accessed from the same assembly
- Can't be assessed from another assembly
```csharp
internal int age;
internal void CalculateBirthDate(){}
```

### Protected Internal
- Can be accessed from the same assembly and in derived classes
```csharp
protected internal int age;
protected internal void CalculateBirthDate(){}
```

### Private Protected
- Can only be accessed within the class or struct in which they are declared and in derived classes in the same assembly
```csharp
private protected int age;
private protected void CalculateBirthDate(){}
```

#!csharp

var staffName = "John";
var Age = 25;
Console.WriteLine(format:"{0} was born {1} years ago.", arg0:staffName, arg1:Age);

#!markdown

---
# **Encapsulation**

#!markdown

Encapsulation is bundling data (attributes) and methods (functions) into a class, and controlling access to the inner workings of that class from the outside world.

Kind of like a wrapper that makes it hard for others to see how it it made, but allows them to use it.
- Allows an object to hide its inner details
- You can use access modifiers (public, private, protected, internal) to control access to the object
- Keeps Your Secrets Safe: Just like you wouldn’t want someone to take your lunch or read your diary, encapsulation keeps important parts of your program safe from accidental changes.
- Makes Things Simpler: You don’t need to know how your video games are made to enjoy playing them, right? Encapsulation lets us use parts of our program without worrying about the complex stuff hidden inside.
- Easy to Update: If you decide to rearrange your locker, it doesn’t really affect your friends, as long as you can still hang out with them. Similarly, with encapsulation, a programmer can change how a part of the program works without messing up the rest.

#!csharp

public class BankAccount
{
    // Private field - Encapsulated data
    private decimal balance;

    // Constructor to initialize the balance
    public BankAccount(decimal initialBalance)
    {
        balance = initialBalance;
    }

    // Public method to deposit money - Interface for outside access
    public void Deposit(decimal amount)
    {
        if (amount > 0)
        {
            balance += amount;
        }
    }

    // Public method to withdraw money - Interface for outside access
    public bool Withdraw(decimal amount)
    {
        if (amount > 0 && balance >= amount)
        {
            balance -= amount;
            return true; // Withdrawal successful
        }
        return false; // Withdrawal failed
    }

    // Public method to get the current balance - Read-only access
    public decimal GetBalance()
    {
        return balance;
    }
}

#!markdown

---
# **Inheritance**

#!markdown

Inheritance is a way of creating more specific classes based on general ones.
- It allows us to define a class in terms of another class, which makes it easier to create and maintain an application.

#!csharp

public class Animal
{
    public string Name { get; set; }
    public int Age { get; set; }

    public void Eat()
    {
        Console.WriteLine("The animal eats.");
    }

    public void Sleep()
    {
        Console.WriteLine("The animal sleeps.");
    }
}

public class Dog : Animal  // Dog is a derived class from the Animal base class
{
    public void Bark()
    {
        Console.WriteLine("The dog barks.");
    }
}

#!markdown

---
# **Polymorphism**

#!markdown

---
# **Abstraction**

#!markdown

---
# **Interface**

#!markdown

---
# **Exceptions** - Try, Catch, Throw, Finally

#!markdown

## What are exceptions
Exception handling lets us manage and respond to errors that happen during our program execution.
- An Exception us an error or unexpected event that occurs during the execution of program that disrupts it normal flow
- Eg - File not found, Divide by zero error, accessing null object

**Why we handle them:**
- To prevent the program from crashing unexpectedly
- Provide more meaningful error messages to users
- Allows us to debug our program
- Lets the program recover gracefully from errors

**Basic Structure of Exception Handling**
- `try` Block: The code that might throw an exception is enclosed in a try block.
- `catch` Block: Code that handles the exception is placed in one or more catch blocks following the try block.
- `finally` Block: (Optional) Code that needs to run regardless of whether an exception occurs or not is placed in a finally block.

#!markdown

## `try-catch-finally` Block
**try:**
- Wrap code that may throw an exception within a try block.
- If an exception occurs, the rest of the code in the try block is skipped.

**catch:**
- Follows the try block and catches exceptions thrown by the try block.
- Can be specific to the type of exception or catch all exceptions.

**finally** Block**
- Executes after the try and catch blocks, regardless of whether an exception was thrown or not.
- Ideal for cleaning up resources, such as closing file streams or database connections.

#!csharp

try {
    // Code that may throw an exception
} catch (ExceptionType ex) {
    // Code to handle the exception
} finally {
    // Code that will always execute even if an exception is thrown
}

#!markdown

## Throw Exception - ```throw ex;```
This is when we catch an exception in a `catch` block, log it, then throw it again.
Three ways to rethrow an exception: 
1. `throw` - throw with its original call stack, then call throw
2. `throw new Exception()`
3. `throw new Exception("message")`

#!markdown

### Rethrowing by throwing without an exception object
Here, the original stack trace is preserved 

#!csharp

void beta () {
    try {
        // Some code that may throw an exception
    } catch (Exception ex) {
        Console.WriteLine($"Caught exception: {ex.Message}");
        throw ex;
    } finally {
        // Code that will always execute even if an exception is thrown
    }
}


try {
    // Some code that may throw an exception
    Gamma();
}
catch (Exception ex)
{
    // Log the exception or perform some other operation
    Console.WriteLine(ex);

    // Log the exception details
    Console.WriteLine(ex.ToString());

    //Throw the caught exception as if it happened here
    //This will lose the original stack trace
    throw ex;


    // Rethrow the exception and retain original call stack
    // This is prefferred
    throw;

    // Throw a new exception with the caught exception nested in it
    throw new Exception(ex.Message, ex);
}

#!markdown

---
# **Collections** - Arrays, ArrayList, List, Dictionary, Hashset

#!markdown

## Arrays
- Defined size
- All elements are of same type

#!csharp

int[] numbers = new int[5] {1, 2, 3, 4, 5};

#!markdown

## ArrayList
- Like an array but can grow and shrink

#!csharp

ArrayList myArrayList = new ArrayList();
myArrayList.Add(1);
myArrayList.Add("Two");

#!markdown

## List
- Like ArrayList but it's a generic type
- - can only hols items of the specified type
- Can grow and shrink

#!csharp

List<int> myIntList = new List<int>();
myIntList.Add(1);
myIntList.Add(2);

#!markdown

## Dictionary <TKey, TValue>
- Holds key-value pairs
- Can look up values by their key
- Ordered
- Uses the **key** as the **index**
- Doesn't allow duplicate keys, but can have duplicate values

#!csharp

Dictionary<string, int> myDictionary = new Dictionary<string, int>();
myDictionary.Add("One", 1);
myDictionary.Add("Two", 2);

#!markdown

## HashSet<Type>
- Collection of unique items
- Usef

#!markdown

---
# **Files**

#!markdown

---
# **Creating a project**

#!markdown

- The name of the solution should be the same as the project
  - Make a project template
Steps
- Create a folder with project name
  - ```Test1```
- Navigate to inside the folder
  - ```Test1>```
- Check template list
  - ```dotnet new list```
- Create solution
  - ```dotnet new sln -n Test1``` or ```dotnet new sln --name Test1``` or ```dotnet new sln```
- Create console app
  - ```dotnet new console -o Test1```
  - or ```dotnet new console -o Test1 -f net8.0``` to use .NET 8.0 specifically
- Add solution
  - ```dotnet sln add Test1.sln```

- 
---
- Create a new project
  - ```dotnet new console```
- Build project
  - ```dotnet build```
- Run project
  - ```dotnet run``` or ```dotnet run -p Test1```

#!markdown

- Don't tamper with the obj folder
- make sure the name you are using is the same as the project name and solution name
- Expect things in program.cs to be already in a main method
  - So no need to write a main method boilerplate code
- Methods have capital names
  - That is why we use 'Main' instead of 'main'
- He will build and run the project from the solutions folder

#!markdown

### Code to make a project

#!pwsh

mkdir Test1 && \
cd Test1 && \
dotnet new sln -n Test1 && \
dotnet new console -o Test1 && \
dotnet sln add Test1/Test1.csproj

#!markdown

string? means that it can be nullable, or its okay if there is no value

- you have control over things that originate in a try block
- the catch bloack is to
  - correct the error
  - stop the program
  - restart the program
- Checks for null values

use as many try and catch as possible
- look for possible issues that can affect the code

#!csharp

WriteLine($"Check");
Write ("Check");
Console.WriteLine("Check");

#!csharp

Console.WriteLine("Check");
Console.Write("Check");
Console.WriteLine("Check");

#!markdown

## Static
If something is static, it belongs to the class.
If not, it belongs to the object.
If we change a static member, it will change for all objects of the class.

#!markdown

---
# **Best Practices**

#!markdown

## Name Conventions

### **_camelCase**

- Private filed instances

```csharp
private int _myField;
```

### **camelCase**:

- local variables
- Method arguments

```csharp
int myLocalVariable = 10;
```

```csharp
public void CalculateAge (int dateOfBirth){
}
```

### **TitleCase / PascalCase:**

- Class names
- Types
- Non-private fields
- Methods
- Other Members
- Properties

```csharp
public class SuperHero{
    public void SuperPower() {}
}
```

```csharp
public int MyProperty { get; set; }
```

### UPPER_CASE_SCORES

- Constants

```csharp
public const int MY_CONSTANT = 10;
```

### INameInterface

- Interfaces
- prefix interface names with an “I”

```csharp
public interface IMyInterface {}
```

#!markdown

## Other best Practices

1. **Use Properties Instead of Public Variables**:
    - Instead of using public variables, use properties to encapsulate them.
2. Use `var` for declaring local variables
3. Avoid using Magic numbers
    - Instead of using numbers directly in our code, use constants or enums to give them meaningful names
4. **Use Meaningful Names**: All names (variables, methods, classes, etc.) should be meaningful and describe what they do.
5. **Follow SOLID Principles**: SOLID is an acronym for five principles that help manage dependencies in your code: Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion.
6. **Exception Handling**: Use try-catch blocks to handle exceptions and provide meaningful error messages.
7. **Use `using` Statements**: When working with types that implement `IDisposable`, use a `using` statement to ensure that the object's `Dispose` method is called when it is no longer needed.
8. **Comment Your Code**: Use comments to explain complex code logic.
9. **Consistent Indentation**: Use consistent indentation to make your code more readable.
10. **Avoid Deep Nesting**: Too many levels of indentation can make code harder to read and understand.

#!markdown

----
# **Parameters**

#!markdown

## How Parameters can be passed

### **By Value**
- Default way passing
- The method gets a copy of the actual value
- - Changes made to the parameter in the method don't affect the original value

#!csharp

void ChangeValue(int x) { x = 10; }  // Does not affect the original value
void PassByValue(int x) { x = 10; }  // Does not affect the original value

#!markdown

### **By Reference with ```ref```**
- in-and-out
- The method gets a reference to the actual value
- Changes made to the parameter in the method affect the original value
- We must put ```ref``` in front of the parameter 
  - e.g ```ref int x```

#!csharp

void ChangeValue(ref int x) { x = 10; }  // Changes the original value
int a = 5;
ChangeValue(ref a);  // Using 'ref'
Console.WriteLine(a);  // Output: 10

void PassByReference(ref int x) { x = 10; }  // Affects the original value

#!markdown

### **Pass by ```in```- read only**
- References the value, but doesn't allow changes to the value
- Compile shows error if changes are being made to it
- It's useful when passing large read-only structures for performance reasons.

#!csharp

void DoSomething(in int x) { /* can't modify x here */ }
int d = 10;
Console.WriteLine(d);  // Output: 10

DoSomething(in d);  // Using 'in'

#!markdown

### **Out parameter with ```out```**
- out only
- The method gets a reference to the actual value
- Similar to ref, but does
- Can't have a default value assigned in their declaration
- Out parameters can't be left uninitialized
- Must be set inside the method; or the compiler will give an error
  - Changes made to the parameter in the method affect the original value

#!csharp

void GetValues(out int x, out int y) { x = 10; y = 20; }  // Outputs two values
int b, c;
GetValues(out b, out c);  // Using 'out'
Console.WriteLine(b);  // Output: 10
Console.WriteLine(c);  // Output: 20

void PassByOutput(out int x) { x = 10; }  // Affects the original value

#!csharp

public void PassingParameters(
        int w,
        in int x,
        ref int y,
        out int z)
{
    z = 100;
    //x++; //We can't change this because it is a read-only reference
    y++;
    z++;

    Console.WriteLine($"In the method: w={w}, x={x}, y={y}, z={z}");
}

int a = 10; int b = 20; int c = 30; //var d = 40;
// Before passing
//Console.WriteLine($"Before passing: w={w}, x={x}, y={y}, z={z}");
//PassingParameters(w, x, ref y, out z);
// After passing
//Console.WriteLine($"After passing: w={w}, x={x}, y={y}, z={z}");

Console.WriteLine($"Before passing: a={a}, b={b}, c={c}");
PassingParameters(a, b, ref c, out int d);
Console.WriteLine($"After passing: a={a}, b={b}, c={c}, d = {d}");

#!markdown

## Combining multiple returned values using tuples
- Each method can only return a single value that has a single type

#!csharp

public (string, int) GetFruit (){
    return ("apple", 42);
}

(string, int) fruit = GetFruit();

Console.WriteLine($"FruitName is {fruit.Item1} and Number is {fruit.Item2}");

#!csharp

public (string Name, int Age) GetPerson(){
    return (Name: "John", Age: 42);
}

(string name, int age) nameAndAge= GetPerson();
Console.WriteLine($"Name is {nameAndAge.Item1} and age is {nameAndAge.Item2}");
Console.WriteLine($"Name is {nameAndAge.name} and age is {nameAndAge.age}");

#!markdown

## Tuples
- It's a data structure that contains a sequence of elements of different data types.
- Can be used where you want to have a data structure to hold and object with properties, but you don't want to have to create a separate type or class
-  tuples are very useful for a quick grouping of related data without having to create a specific class or struct
-  You can access the elements in a tuple using Item1, Item2, Item3, etc.
-  You can't iterate over tuples like we do with arrays or lists

#!csharp

var person = Tuple.Create("John", "Doe", 30);
//person is a tuple that contains three elements of types string, string, and int.

#!csharp

var person = ("Name", "LastName", 0);
person.Item1 = "John";
person.Item2 = "Doe";
person.Item3 = 30;

string firstName = person.Item1;  // "John"
string lastName = person.Item2;   // "Doe"
int age = person.Item3;           // 30

Console.WriteLine(person.Item1);
Console.WriteLine(person.Item2);
Console.WriteLine(person.Item3)

#!csharp

var person = (Firstname: "Name", Lastname: "Name", Age: 0);
person.Item1 = "John";
person.Item2 = "Doe";
person.Item3 = 30;

string firstName = person.Item1;  // "John"
string lastName = person.Item2;   // "Doe"
int age = person.Item3;           // 30

Console.WriteLine(person.Firstname);
Console.WriteLine(person.Lastname);
Console.WriteLine(person.Age);

#!markdown

### Nested tuples
Tuples can contain another tuple as one of its elements

#!csharp

var outerTuple = new Tuple<int, Tuple<string, string>>(1, new Tuple<string, string>("Hello", "World"));

Console.WriteLine(outerTuple.Item1);  // Outputs: 1
Console.WriteLine(outerTuple.Item2.Item1);  // Outputs: Hello
Console.WriteLine(outerTuple.Item2.Item2);  // Outputs: World

#!csharp

var outerTuple = (1, ("Hello", "World"), "Stringent");

Console.WriteLine(outerTuple.Item1);  // Outputs: 1
Console.WriteLine(outerTuple.Item2.Item1);  // Outputs: Hello
Console.WriteLine(outerTuple.Item2.Item2);  // Outputs: World

#!csharp

var outerTuple = (Number: 1, InnerTuple: (First: "Hello", Second: "World"));

Console.WriteLine(outerTuple.Number);  // Outputs: 1
Console.WriteLine(outerTuple.InnerTuple.First);  // Outputs: Hello
Console.WriteLine(outerTuple.InnerTuple.Second);  // Outputs: World

#!markdown

---
# **Properties & Indexers**

#!markdown

## Properties
Property is a member of a class or struct that allows us to read, write, or compute the value of a private field.
- Can be used like they are public data members but they are actually special methods called accessors
- Allows us to protect our fields from being accessed directly

#!csharp

//Here, Name is a property.
//The get accessor returns the value of name.
//The set accessor sets the value of name.
//The value keyword is the value assigned to the property
public class Person
{
    private string name;  // Private field

    // Property
    public string Name
    {
        get { return name; }  // Get accessor
        set { name = value; } // Set accessor
    }
}

#!markdown

## Controlling access with properties and indexers
- Differences between a field and a property
- fields are used to store data, properties provide a way to protect that data and add additional logic when getting or setting the values, and indexers allow an object to be indexed like an array

#!markdown

## Field
- A field is a variable that is declared directly in a class or struct in C#.
- It can be public or private, static or not, and it can be a value type or reference type.
- It represents the data it holds

#!csharp

public class MyClass
{
    public string myField;  // This is a field
}

#!markdown

## Indexer
- this allows an object to be indexed and accessed similar to an array
-  It's a syntactic convenience that allows you to create a class that can be accessed just like an array for one of its collections.

#!csharp

public class MyClass
{
    private int[] array = new int[10];

    public int this[int index]  // This is an indexer
    {
        get { return array[index]; }
        set { array[index] = value; }
    }
}


MyClass myObject = new MyClass();
myObject[0] = 42;  // Using the indexer to set a value
int value = myObject[0];  // Using the indexer to get a value

#!markdown

### Defining read-only Properties
- Property that allows us to get the valeu, but not set it
- Useful when you want to expose a property but not let it be modified externally

#!csharp

public string Name {
    get { return name; }
}

public string ToString() {
    get {
        return $"Name: {name}"; 
    }
}

#!csharp

public class Cheese
{
    private int _age;
    public Cheese(int value){
        _age = value;
    }

    public int Age {
        get{
            return _age;
        }
    }
}

#!markdown

### Defining Settable Properties
- Allows us to get and set a value

#!csharp

public string Name { get; set; }

#!markdown

### Requiring Properties to be set during instantiation

#!markdown

## Init-Only Properties

#!markdown

### Record Types

#!markdown

---
# **Interface**

#!csharp

public class Person {
    public string Name { get; set; }

    public DateTime DateOfBirth { get; set; }
    
    public int Age { get; set; }
}

#!markdown

## Static Methods and Overloading Operators
A static method is a method that can be called directly from a class without creating an object instance.
- They can only access static members of the class
- Can't use the ```this``` keyword in a static method
- They are 

#!markdown

---
# **Reference and Value Types**

#!markdown

There are 2 categories of memory
### Stack Memory
- Faster to work with
- managed directly by CPU
- Uses a last-in-first-out machanism like a stack
- More likely to have data in L1 or L2 cache
- Limited in size

### Heap Memory
- Slower to work with
- managed by the OS
- Uses a first-in-first-out machanism like a queue
- More likely to have data in L3 cache

#!markdown

## value Type
They include basic types such as int, float, double, and DateTimeOffset, as well as structures (struct).
- When you create a value type, the value is stored directly in the location where the variable is allocated.
- For local variables, this is typically on the stack, which is a region of memory that stores data in a last-in, first-out manner. This means that each value type has its own copy of the data, and operations on one do not affect another.

```int number1 = 49;```
- number1 variable is a value type or struct
- is allocated on the stack
-uses 4 bytes of memory since it is a 32-bit integer

#!markdown

## Reference Type (Class)
```
Person kevin = new()
{Name = "Kevin", DateOfBirth = new (year:1988, month:9, day:23) };
```
- The kevin variable is a reference stack
- 8 bytes of a 64-bit memory address(on a 64bit OS) is reserved on the stack
- Enough bytes is reserved on the head to store instance of a Person

#!markdown

## Boxing & Unboxing
This is when a value type is moved to a
- Process of converting a value type to the type object or to any interface type implemented by this value type.

### Unboxing
This extracts 


- Boxing and unboxing operations have a negative impact on performance
    - Up to 20 times slower
- However, there might be other things that take more time like 

#!csharp

//Example of boxing
int val = 123;  // Value type
object obj = val;  // Boxing
Console.WriteLine(obj);

//Example of Unboxing
obj = 123;  // Boxing
val = (int)obj;  // Unboxing
Console.WriteLine(val);

int n = 3;
object o = n; //Boxing happens implicitly
n = (int) o; // Unboxing

#!markdown

## Equallity of types
- We use `==` and `!=` to compare two values
- This is different for reference types and value types
- For value types, the values are compared
- For reference types, the references are compared
    - But this is problematice because it checks if they are the same object
    - But they are not
    - This is because they have different memory addresses

#!csharp

int a = 4;
int b = 4;
int c = 5;

Console.WriteLine($"a==b:{(a == b)}");
Console.WriteLine($"b==c:{(b == c)}");

#!csharp

Person p1 = new() {Name = "Kevin", Age = 20};
Person p2 = new() {Name = "Kevin", Age = 20};
Console.WriteLine(p1 == p2); // False

#!csharp

Console.WriteLine(a == c); // False

#!markdown

---
# **Struct Types**
- 

#!markdown

---
# **Polymorphism**
